x = pitch
y = yaw
z = roll

pseudocode for building up a GameObject components
somehow the engine needs to know how many components the object will have BEFORE it's built
preferably without manually returning some number statically, as this is wildly error-prone
the reason the engine needs to know is to allocate the component array. otherwise memory is wasted,
or potentially allocated repeatedly at runtime. in order to avoid fragmentation, the engine needs to know

Boiling it down to its basics, the engine doesn't really have to know, it just needs to be able to provide
a contiguous array of pointers to the created components.
One possible fix is to have the constructor receive a ComponentBuilder or something along those lines:

TestGameObject(ComponentBuilder* builder)
{
	StaticMeshComponent* myMesh = builder->AddComponent<StaticMeshComponent>(this);
}

once the constructor is done running, whatever function created the game object would be holding the ComponentBuilder
which would have a count of the created components. It could then allocate the array, but then filling it would be a challenge.

one other possibility would be to have a hidden static member of each gameobject that holds this total component count
if it hasn't been filled (set to a default value of -1) then the engine creates a dummy that just initializes this value
then the value is initialized for the rest of the runtime, and can be referenced ahead of time (kinda like a default object)

MyGameMode::SpawnPlayer()
{
	// ... some code to get a spawn point and whatnot

	PlayerObject* playerInstance = GetWorld()->SpawnGameObject<PlayerObject>();
}

...

template <class T>
World::SpawnGameObject()
{
	
}